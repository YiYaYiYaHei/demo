<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>关系图-关系伸缩</title>
    <script src="../js/echarts-4.2.0.js"></script>
    <style>
        .chart {
            height: 600px;
            margin: 50px 100px 0 100px;
            border: 1px solid #999999;
        }
    </style>
</head>
<body>
<div class="chart"></div>
<script>
    let chart = echarts.init(document.querySelector('.chart'));

    // 初始时只有一个点
    let categories = [
        {name: '0'}
    ];
    let option = {
        legend: {
            textStyle: {
                color: '#666'
            },
            icon: 'circle',
            data: categories
        },
        series: [
            {
                type: 'graph',
                layout: 'force',
                force: {
                    repulsion: 500,
                    edgeLength: 30,
                    initLayout: 'circular',
                    layoutAnimation: false
                },
                edgeSymbol: ['', 'arrow'],
                edgeSymbolSize: [0, 7],
                roam: true,
                label: {
                    show: true,
                    position: 'right'
                },
                focusNodeAdjacency: true,
                categories,
                data: [
                    {
                        name: '0',
                        symbolSize: 35
                    }
                ],
                links: []
            }
        ]
    };

    chart.setOption(option);

    chart.on("click", function(parentNode) {

        let option = chart.getOption();
        let [data, links, categories] = [option.series[0].data, option.series[0].links, option.series[0].categories];

        // 判断当前节点是否已经有子节点
        let hasChild = links.findIndex(item => item.source == parentNode.name) != -1;

        if (!hasChild) {

            // 新增的子节点的所属类型 （为当前父节点所属类型 + 1）
            let category = parseInt(parentNode.name.split('-')[0]) + 1;

            // 不存在对应的category
            if (undefined == categories[category]) {

                categories.push({name: category, value: 0});
                option.legend[0].data.push({name: category});
            }

            // 需要增加的子节点的个数
            let newNodeLength = (Math.random() * 10) % 4 + 1;

            // 增加子节点
            for (let i = 0; i < newNodeLength; i++) {

                let index = ++categories[category].value;
                data.push({
                    name: `${category}-${index}`,
                    category,
                    symbolSize: 30 - category * 3 < 10 ? 10 : 30 - category * 3,
                });
                links.push({
                    source: parentNode.name,
                    target: `${category}-${index}`
                });
            }

            chart.clear();
            chart.setOption(option, true);
        } else {

            // 删除当前节点相关数据
            filter(option.series[0].data, option.series[0].links, parentNode);

            chart.clear();
            chart.setOption(option, true);
        }
    });

    function filter(data, links, node, isDelNode = true) {

        // 删除目标节点(要先删除节点，不然递归的时候会出问题，节点一直存在造成死循环)
        let [nodeName, category] = [{...node}.name, null];
        if (isDelNode) {

            //categories.splice(categories.findIndex(item => item.category == category), 1);
            data.splice(data.findIndex(item => item.name ==  node.name), 1);
        }

        // 遍历节点连线
        for (let i = 0; i < links.length; i++) {

            // 向下的连线(不仅要删除线还要删除target那个点)、向上的连线(只删除线)
            if (links[i].source == nodeName || links[i].target == nodeName) {

                let temp = Object.assign({}, links[i]);

                filter(data
                    , links.splice(i, 1)
                    , data.find(item => item.name ==  temp.target)
                    , temp.source == nodeName);
                i--;
            }
        }
    }
</script>
</body>
</html>